1. This program is meant to demonstrate what happens when
a child process terminates before the parent process.
2. A, C
3. A, B
4.
    ps -f --forest -o user,pid,ppid,state,ucmd
    tklaback 3487101 3487100 S bash
    tklaback 3487180 3487101 S  \_ fork
    tklaback 3487181 3487180 S      \_ fork

    ps -f --forest -o user,pid,ppid,state,ucmd
    tklaback 3351507 3351506 S bash
    tklaback 3352786 3351507 S  \_ fork
    tklaback 3352787 3352786 Z      \_ fork <defunct>

5. The difference between these two outputs is that after the first 30 seconds, 
the child process exits and the parent is still alive. Because the parent does not
reap the child, the child remains a zombie for the last 30 seconds until the
parent terminates. The first 30 seconds, however, the child is running.

6. You could add a wait(int *status) in section c, where the parent code executes
in order to reap the child as soon as it terminates.

7. This would most likely go before the sleep(60) in section C.

8.
    tklaback@mainstay:~$ ps -f --forest -o user,pid,ppid,state,ucmd
    USER         PID    PPID S CMD
    tklaback 3487109 3487100 S bash
    tklaback 3487784 3487109 R  \_ ps
    tklaback 3487101 3487100 S bash
    tklaback 3487775 3487101 S  \_ fork
    tklaback 3487776 3487775 S      \_ fork
    tklaback 3487051 3487046 S bash
    tklaback 3487098 3487051 S  \_ tmux: client
    tklaback@mainstay:~$ ps -f --forest -o user,pid,ppid,state,ucmd
    USER         PID    PPID S CMD
    tklaback 3487109 3487100 S bash
    tklaback 3487793 3487109 R  \_ ps
    tklaback 3487101 3487100 S bash
    tklaback 3487775 3487101 S  \_ fork
    tklaback 3487051 3487046 S bash
    tklaback 3487098 3487051 S  \_ tmux: client

9. Now, the difference between the two outputs is the first one shows both
parent and child processes running, but the second one just shows the parent 
process since its child process terminated and was reaped.

10.

    tklaback@mainstay:~$ ps -f --forest -o user,pid,ppid,state,ucmd
    USER         PID    PPID S CMD
    tklaback 3487109 3487100 S bash
    tklaback 3488121 3487109 R  \_ ps
    tklaback 3487101 3487100 S bash
    tklaback 3488105 3487101 S  \_ fork
    tklaback 3488106 3488105 S      \_ fork
    tklaback 3487051 3487046 S bash
    tklaback 3487098 3487051 S  \_ tmux: client

    tklaback@mainstay:~$ ps -f --forest -o user,pid,ppid,state,ucmd
    USER         PID    PPID S CMD
    tklaback 3487109 3487100 S bash
    tklaback 3488148 3487109 R  \_ ps
    tklaback 3487101 3487100 S bash
    tklaback 3487051 3487046 S bash
    tklaback 3487098 3487051 S  \_ tmux: client
    tklaback 3488106       1 S fork

11. The difference between these two outputs is that in the first output, both 
parent and child processes are running. Because the parent process exits before
the child process, the second output shows that the parent process is no longer
running and that the child's new parent process is the init process.

12.
BEFORE FORK (3)
SECTION C (3)
SECTION B (3)

13. All of the processes wrote to the file.

question: If the parent process already called fclose on the file, how is the child still able to write to
it?

14. Based on the output to stdout and to fork-output.txt, the child inherited all of the open file descriptors
from the parent. The child can modify the same files as the parent.

15. Based on the output in fork-output.txt, the second write picked up where the first write left off. This
happened because both processes contain the same open file descriptor.

16. 